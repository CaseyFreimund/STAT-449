```{r}
#Loads in required packages
library(PerformanceAnalytics)
library(psych)
library(cluster)
library(fpc)
library(ggplot2)
library(pROC)
library(car)
library(gridExtra)
```


```{r}
#READS TABLE
hd=read.table("processed.heartdisease.txt",sep = ",",header = TRUE)
hd
```

#1
```{r warning=FALSE}
#Changes all columns to numeric values
hd$ca=as.numeric(levels(hd$ca)[hd$ca])
hd$thal=as.numeric(levels(hd$thal)[hd$thal])

#Finds columns with NA values and replaces them with the Median value of that column
colnames(hd)[colSums(is.na(hd)) > 0]
hd$ca[is.na(hd$ca)] = median(hd$ca,na.rm = TRUE)
hd$thal[is.na(hd$thal)] = median(hd$thal,na.rm = TRUE)
hd
```

```{r}
#Un-comment Below to change num to 0=no heart disease and 1=heart disease
hd.all.level=hd
hd$num=sapply(hd$num,function(x) replace(x,x>0,1))

#Enhanced correlation matrix
chart.Correlation(hd[,c(10,11)],histogram = FALSE)
chart.Correlation(hd[,c(13,14)],histogram = FALSE)
```

```{r}
#EFA of Variables
mat=cor(hd)
cortest.bartlett(mat,n=303)
KMO(mat)

fa.out=principal(hd[,-c(2,6,14)],nfactors=4,rotate="varimax")
print.psych(fa.out,cut=.5,sort=TRUE)


```

```{r, fig.align='center', echo=FALSE}
#Scaling data for clustering
hd.scaled=scale(hd[,-c(2,6,14)])
hd.dist=dist(hd.scaled)

hd.scaled2=scale(hd.all.level[,-c(2,6,14)])
hd.dist2=dist(hd.scaled2)

#Finding the MDS coordinates of the observations and graphing them to show a differences in the observations.
hd.mds = cmdscale(hd.dist, eig=T)
mds.coords=data.frame(Coordinate1=hd.mds$points[,1],Coordinate2=hd.mds$points[,2],diagnosis=as.factor(hd$num))

hd.mds2 = cmdscale(hd.dist2, eig=T)
mds.coords2=data.frame(Coordinate1=hd.mds2$points[,1],Coordinate2=hd.mds2$points[,2],diagnosis=as.factor(hd.all.level$num))

par(mfrow=c(2,1))
ggplot(mds.coords,aes(Coordinate1,Coordinate2,color=diagnosis))+geom_point()+scale_color_manual(values=c("#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00"))
ggplot(mds.coords2,aes(Coordinate1,Coordinate2,color=diagnosis))+geom_point()+scale_color_manual(values=c("#e41a1c","#377eb8","#4daf4a","#984ea3","#ff7f00"))
# grid.arrange(level4d,level1d,ncol=2,widths=4)
```



```{r}
#Clustering of Observations

#Scree Plot
output=princomp(hd[,-c(2,6,14)], cor=TRUE)
plot(output,type="lines")
abline(h=1,lty=2)

#K-Means clustering into 2 groups
hd.k2=kmeans(hd.scaled, centers=2, iter.max=100, nstart=25)
hd.k2.clust=lapply(1:2, function(nc) hd$num[hd.k2$cluster==nc])

#Ward Method of Clustering into 2 groups
hd.ward.link=hclust(hd.dist, method='ward.D2')
cut.2 <- cutree(hd.ward.link, k=2)
ward.2.clust <- lapply(1:2, function(nc) hd$num[cut.2==nc])

#Cluster Stats for comparing K-Means Clustering and Ward's Method
cluster.stats(hd.dist, cut.2, hd.k2$cluster, compareonly=T)
```

```{r}
#Plots for K-Means Cluster

#Silhouette Plot---> Needs to be opened in a new window.
hd.k2.sil <- silhouette(hd.k2$cluster, hd.dist)
plot(hd.k2.sil, main ="Silhouette plot - K-means")

#Clusplot
clusplot(hd, hd.k2$cluster, main='2D representation of the Cluster solution',color=TRUE, shade=TRUE,labels=2, lines=0)
```

```{r}
#Plots for Ward's Method Clusters

#Silhouette Plot---> Needs to be opened in a new window.
ward.sil <- silhouette(cut.2, hd.dist)
plot(ward.sil, main ="Silhouette plot - Ward's Method")

#Clusplot
clusplot(hd, cut.2, main='2D representation of the Cluster solution',color=TRUE, shade=TRUE,labels=2, lines=0)
```

```{r}
#factoring
hd$sex=factor(hd$sex)
hd$cp=factor(hd$cp)
hd$fbs=factor(hd$fbs)
hd$restecg=factor(hd$restecg)
hd$exang=factor(hd$exang)
hd$slope=factor(hd$slope)
hd$thal=factor(hd$thal)
hd$ca=factor(hd$ca)

#full model
hdmod1 <- glm(num~., data = hd)
summary(hdmod1)
hdpred1 <- predict(hdmod1, type="response")
hdroc1 <- roc(hd$num, hdpred1)
hdroc1

library(lmtest)
bptest(hdmod1)##testing for heteroskedasticity
vif(hdmod1)##testing for multicollinearity


#model based on choosing lowest p value from cluster groups
hdmod2 <- glm(num~oldpeak+cp+ca+restecg+thal+thalach+trestbps, data = hd)
summary(hdmod2)
hdpred2 <- predict(hdmod2, type="response")
hdroc2 <- roc(hd$num, hdpred2)
hdroc2
#trestbps isn't significant, but removing it will decrease AUC

```

```{r}
#model based on choosing lowest p value from cluster groups
hdmod3 <- glm(num~sex+cp+exang+slope+ca+thal,data = hd)
summary(hdmod3)
hdpred3 <- predict(hdmod3, type="response")
hdroc3 <- roc(hd$num, hdpred3)
hdroc3

#roc curve 
plot(hdroc3, print.thres="best")

#misclassification rate
correct.s<-rep(0,times=nrow(hd))
mypred.s <- rep(0,times=nrow(hd))
for (j in 1:nrow(hd)) {
  glm.fit.no.j<-glm(num ~ sex + cp + exang + slope + ca + thal, data=hd, subset=-j)
  mypred.s[j]<-(predict(glm.fit.no.j,newdata=hd[j,],type='response') > 0.529)
  correct.s[j] <- (mypred.s[j]==hd$num[j])
}
cv.misclass.s <- 1-mean(correct.s)
cv.misclass.s

pred.reduced.hd <- ifelse(hdpred3 < .529, 0, 1)
table(pred.reduced.hd, hd$num)
spec = 152/(152+27)
sens = 112/(112+12)
spec
sens

#trestbps isn't significant, but removing it will decrease AUC
anova.check=anova(hdmod3,hdmod1)
anova.check
1-pchisq(-diff(anova.check$`Resid. Dev`), anova.check$Df[2])

#prediction
newobs <- rbind( c('0','3','0','1', '1' ,'3'))
dimnames(newobs) <- list(NULL,c('sex','cp', 'exang', 'slope', 'ca', 'thal'))
newobs <- data.frame(newobs)
predict.glm(hdmod3,newdata=newobs)

```
